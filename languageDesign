= Refinement type for memory and thread safety

== Thread Safety

thread_spawn(value: T)
    ensure is_unique(T)

give lifetime to thread (to share references between threads)?

Think about sharing data between threads:
maybe allow the programmer to specify that a value is shareable:

let spin_lock(): SpinLock
    assume is_shareable(result)
Markers are probably better for that? Does the compiler need to know the concept of shareability?

Safe atomics: https://readthedocs.org/projects/ats-documentation/downloads/pdf/latest/

=== Markers

Markers are a way to say what a type is.

mark Send

assume(i32.is(Send))

fn thread_spawn(callback: fn())
    ensure callback.is(Send)

== Inspirations

Essayer le langage Whiley.

== Memory Safety

=== No dangling reference

let vector_get(&vector): &a

let vector_push(&vector, a)
    ensure is_unique(&vector)

Can we generalize this to allow multiple mutable references on the vector?

Cannot return reference to local variable.
Cannot move non-static reference to move function.

=== No memory leak

For ensuring memory deallocation, have post-condition like:

let malloc(): ptr
    ensure result == 0 || will_call(free(result))
This seems complicated. Think about something else inspired by linear types, maybe:
let malloc(): ptr
    ensure result == 0 || will_consume(result)

=== No access to uninitialized values

Think about uninitialized values (from malloc).
No implicit free to avoid freeing uninitialized memory.
Functions to work with uninitialized memory.

== User-friendlyness

=== Less boilerplate

Permissions are an alias for a precondition.

perm mut(type) = is_unique(type)

let vec_push(&mut self, element: T) // mut is the permission defined earlier.

Maybe we don't need permissions. It could only be types:

&mut could be a generic type

type &mut T = *T
ensures is_unique(*T)

=== Freeing memory

To free memory at the end of a function:
defer free()

=== Indexing

Allow to use u8, u16, u32 and u64 instead of usize if their size (or value?) <= size_of(usize).
Same for i8, i16, i32, i64 if they are greater than or equal to 0.

=== Arrays

Allow multiple shared references to the same array if we can prove that the indexes are different?

=== Lifetimes

Is the concept of lifetimes implicit or explicit in
let vector_get(&vector, &useless): &a
?
If it's implicit, it means the compiler needs to do a whole program analysis before being able to infer the lifetimes here.
Isn't it what the type inference do anyway?

== Strings

Use latin1?
